#define PLAY_IMPLEMENTATION
#define PLAY_USING_GAMEOBJECT_MANAGER 
#include "Play.h"

int DISPLAY_WIDTH = 1280;  //global variables: stores the dimension of PlayBuffer
int DISPLAY_HEIGHT = 720;
int DISPLAY_SCALE = 1;

struct GameState //created to remember the overall state of the game
{
	int score = 0;
};

GameState gameState; //creating an instance in global scope so the game state can be accessed anywhere

enum GameObjectType
{
	TYPE_NULL = -1, //-1 to represent uninitialised gameobject types
	TYPE_AGENT8,
	TYPE_FAN,
	TYPE_TOOL,
	TYPE_COIN,
	TYPE_STAR,
	TYPE_LASER,
	TYPE_DESTROYED,
};

void HandlePlayerControls(); //declaration for player control functions
void UpdateFan();
void UpdateTools();
void UpdateCoinsAndStars();

//entry point for the windows program
void MainGameEntry(PLAY_IGNORE_COMMAND_LINE)
{
	Play::CreateManager(DISPLAY_WIDTH, DISPLAY_HEIGHT, DISPLAY_SCALE);
	Play::CentreAllSpriteOrigins();
	Play::LoadBackground("Data\\Backgrounds\\background.png");
	//Play::StartAudioLoop("music");
	Play::CreateGameObject(TYPE_AGENT8, { 115, 0 }, 50, "agent8"); //object, position, collision radius, which sprite to use for object
	int id_fan = Play::CreateGameObject(TYPE_FAN, { 1140, 217 }, 0, "fan");
	Play::GetGameObject(id_fan).velocity = { 0,3 };
	Play::GetGameObject(id_fan).animSpeed = 1.0f;
}

//Called by the PlayBuffer once every frame (60 times a second)
bool MainGameUpdate(float elapsedTime)
{
	Play::DrawBackground();
	HandlePlayerControls();
	UpdateFan();
	UpdateTools();
	UpdateCoinsAndStars(); 
	Play::PresentDrawingBuffer();
	return Play::KeyDown(VK_ESCAPE);
}

int MainGameExit(void)
{
	Play::DestroyManager();
	return PLAY_OK; 
}

void HandlePlayerControls()
{
	{
		GameObject& obj_agent8 = Play::GetGameObjectByType(TYPE_AGENT8); //accessing object through play manager
		if (Play::KeyDown(VK_UP))
		{
			obj_agent8.velocity = { 0, -4 };
			Play::SetSprite(obj_agent8, "agent8_climb", 0.25f); //change sprite to the other and setting animation speed 
		}
		else if (Play::KeyDown(VK_DOWN))
		{
			obj_agent8.acceleration = { 0, 1 };
			Play::SetSprite(obj_agent8, "agent8_fall", 0);
		}
		else
		{
			Play::SetSprite(obj_agent8, "agent8_hang", 0.02f);
			obj_agent8.velocity *= 0.5f;
			obj_agent8.acceleration = { 0,0 };
		}
		Play::UpdateGameObject(obj_agent8);

		if (Play::IsLeavingDisplayArea(obj_agent8))
			obj_agent8.pos = obj_agent8.oldPos;

		Play::DrawLine({ obj_agent8.pos.x, 0 }, obj_agent8.pos, Play::cWhite);
		Play::DrawObjectRotated(obj_agent8); //used instead of drawobject as sprite will be rotated 
	}
} 

void UpdateFan()
{
	GameObject& obj_fan = Play::GetGameObjectByType(TYPE_FAN); //creating obj_fan to retrieve FAn 
	if (Play::RandomRoll(50) == 50) //rolling 50 on a 50 sided die
	{
		int id = Play::CreateGameObject(TYPE_TOOL, obj_fan.pos, 50, "driver"); //creating tool at fan position
		GameObject& obj_tool = Play::GetGameObject(id);
		obj_tool.velocity = Point2f(-8, Play::RandomRollRange(-1, 1) * 6); //randomly generating velocity for y-axis: -1 or 0 or 1 and multiplying by 6: diag up, straight, diag down 

		if (Play::RandomRoll(2) == 1) //50% chance to become a spanner tool
		{
			Play::SetSprite(obj_tool, "spanner", 0);
			obj_tool.radius = 100;
			obj_tool.velocity.x = -4;
			obj_tool.rotSpeed = 0.1f;
		}
		Play::PlayAudio("tool"); //spawning sound effect
	}
	if (Play::RandomRoll(150) == 1) //rolling 1 on a 150 side die
	{
		int id = Play::CreateGameObject(TYPE_COIN, obj_fan.pos, 50, "coin");
		GameObject& obj_coin = Play::GetGameObject(id);
		obj_coin.velocity = { -3, 0 };
		obj_coin.rotSpeed = 0.1f;
	}
	Play::UpdateGameObject(obj_fan); //called to process the objects movements

	if (Play::IsLeavingDisplayArea(obj_fan))
	{
		obj_fan.pos = obj_fan.oldPos; //resetting its position
		obj_fan.velocity.y *= -1;	//reversing its y-axis velocity
	}
	Play::DrawObject(obj_fan);
}

void UpdateTools()
{
	GameObject& obj_agent8 = Play::GetGameObjectByType(TYPE_AGENT8);
	std::vector<int> vTools = Play::CollectGameObjectIDsByType(TYPE_TOOL);

	for (int id : vTools) //goes through each item in the vector and assigns the unique id to the local id variable
	{
		GameObject& obj_tool = Play::GetGameObject(id);

		if (Play::IsColliding(obj_tool, obj_agent8))
		{
			Play::StopAudioLoop("music");
			Play::PlayAudio("die");
			obj_agent8.pos = { -100, 100 }; //player is hidden offscreen instead of being destroyed
		}
		Play::UpdateGameObject(obj_tool);

		if (Play::IsLeavingDisplayArea(obj_tool, Play::VERTICAL))
		{
			obj_tool.pos = obj_tool.oldPos;
			obj_tool.velocity.y *= -1;
		}
		Play::DrawObjectRotated(obj_tool);

		if (!Play::IsVisible(obj_tool))
			Play::DestroyGameObject(id); //destroyobjects like these that are being cont created to avoid overloading memory and process
	}
}

void UpdateCoinsAndStars()
{
	GameObject& obj_agent8 = Play::GetGameObjectByType(TYPE_AGENT8);
	std::vector <int> vCoins = Play::CollectGameObjectIDsByType(TYPE_COIN);

	for (int id_coin : vCoins)
	{
		GameObject& obj_coin = Play::GetGameObject(id_coin);
		bool hasCollided = false;

		if (Play::IsColliding(obj_coin, obj_agent8))
		{

		}
	}

}